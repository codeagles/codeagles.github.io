<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker启动Java项目报异常:FontConfiguration.getVersion(FontConfiguration.java:1264)</title>
      <link href="/2019/05/06/Docker%E5%90%AF%E5%8A%A8Java%E5%AD%97%E4%BD%93%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/05/06/Docker%E5%90%AF%E5%8A%A8Java%E5%AD%97%E4%BD%93%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>使用docker部署SpringBoot项目时，验证码代码恰好调用了JDK1.8底层的FontConfiguration这个类生成图片。<br>结果前端调用的时候抛了个异常。如下</p><a id="more"></a><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">java.lang.NullPointerException: </span>null</span><br><span class="line">        <span class="built_in">at</span> sun.awt.FontConfiguration.getVersion(FontConfiguration.<span class="keyword">java:1264)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> sun.awt.FontConfiguration.readFontConfigFile(FontConfiguration.<span class="keyword">java:219)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> sun.awt.FontConfiguration.init(FontConfiguration.<span class="keyword">java:107)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> sun.awt.X<span class="number">11F</span>ontManager.createFontConfiguration(X<span class="number">11F</span>ontManager.<span class="keyword">java:774)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> sun.font.SunFontManager$<span class="number">2</span>.run(SunFontManager.<span class="keyword">java:431)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">java.security.AccessController.doPrivileged(Native </span>Method)</span><br><span class="line">        <span class="built_in">at</span> sun.font.SunFontManager.&lt;init&gt;(SunFontManager.<span class="keyword">java:376)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> sun.awt.FcFontManager.&lt;init&gt;(FcFontManager.<span class="keyword">java:35)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> sun.awt.X<span class="number">11F</span>ontManager.&lt;init&gt;(X<span class="number">11F</span>ontManager.<span class="keyword">java:57)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">        <span class="built_in">at</span> sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.<span class="keyword">java:62)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.<span class="keyword">java:45)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">java.lang.Class.newInstance(Class.java:442)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> sun.font.FontManagerFactory$<span class="number">1</span>.run(FontManagerFactory.<span class="keyword">java:83)</span></span><br><span class="line"><span class="keyword"> </span>       <span class="built_in">at</span> <span class="keyword">java.security.AccessController.doPrivileged(Native </span>Method)</span><br><span class="line">        <span class="built_in">at</span> sun.font.FontManagerFactory.getInstance(FontManagerFactory.<span class="keyword">java:74)</span></span><br><span class="line"><span class="keyword"> </span>       ......</span><br><span class="line">        .....</span><br><span class="line">        <span class="comment"># 不继续贴了 太多了</span></span><br></pre></td></tr></table></figure><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>比较有效的解决办法是装ttf-dejavu<br>修改前Dockerfile：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="bash">ADD xx.jar app.jar</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></span><br></pre></td></tr></table></figure></p><p>追加一句话重新打包、编译、部署即可。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">RUN</span> apk <span class="builtin-name">add</span> --update font-adobe-100dpi ttf-dejavu fontconfig</span><br></pre></td></tr></table></figure></p><p>修改后Dockerfile：<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jdk-alpine</span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /tmp</span></span><br><span class="line"><span class="bash">ADD xx.jar app.jar</span></span><br><span class="line"><span class="bash">RUN apk add --update font-adobe-100dpi ttf-dejavu fontconfig</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"java"</span>,<span class="string">"-Djava.security.egd=file:/dev/./urandom"</span>,<span class="string">"-jar"</span>,<span class="string">"/app.jar"</span>]</span></span><br></pre></td></tr></table></figure></p><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>由于验证码需要的特殊字体在系统里是不存在的，不过sun的JDK是可以调用的，而openJDK不行，所以要么换JDK、要么安装字体库。</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
          <category> 那些年走过的坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
            <tag> docker </tag>
            
            <tag> win </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红酒入门系列之酒杯的分类</title>
      <link href="/2019/05/03/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%85%92%E6%9D%AF%E7%9A%84%E5%88%86%E7%B1%BB/"/>
      <url>/2019/05/03/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%85%92%E6%9D%AF%E7%9A%84%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="一、酒杯的分类"><a href="#一、酒杯的分类" class="headerlink" title="一、酒杯的分类"></a>一、酒杯的分类</h1><p>在之前的文章中我们了解了关于葡萄酒的故事、葡萄酒的分类，那么今天我想跟大家聊一聊葡萄品种与酒性。我们知道产区不同会使它的香气，果味，酸度，单宁和酒度，也均相互异同。在这个过程当中酒杯虽然不会改变酒的本质，但是酒杯的形状却可以决定酒的流向，气味，品质以及强度，进而影响酒的香度，味道，平衡性，以及余韵。今天让我们一起了解红葡萄酒，白葡萄酒，甜酒，起泡酒以及白兰地等各自适用的杯型。</p><a id="more"></a><h3 id="–持杯方式"><a href="#–持杯方式" class="headerlink" title="–持杯方式"></a>–持杯方式</h3><p>现在的社会中人们越来越注重身材，那么其实在葡萄酒杯的选择当中，身材也决定着他们的命运，不同的杯型会产生不同的作用吗？它的原理又是什么呢？</p><p><img src="http://img.codeagles.com/酒杯.png" alt="酒杯种类"></p><p>那么接下来，我们就拿这个杯子来给大家举个例子</p><p><img src="http://img.codeagles.com/握杯.png" alt="握杯"></p><p>我们从下往上看，这个杯子的基座就不用多说了，会使酒杯保持稳定，不会摔倒，而杯柄，有两个重要的作用，</p><ul><li>首先，研究者可以在不接触杯肚的情况下，稳定的持杯，而手接触杯肚会使酒杯升温，这对于需要冷却使用的葡萄酒来说是尤为不利的。</li><li>其次，杯柄可以使人手远离杯沿。为什么手不应该离杯肚太近呢？因为我们的手上，有时候会涂例如手霜之类的物质，它是有气味的，尤其是使用香皂等带有香味的东西洗手之后，这些气味会影响饮酒者对葡萄酒香气的感知，你会看到有的专业品酒师喜欢用手拿着基座(如上图)，也就是这个原因了。</li></ul><p>那么我们在握杯的时候，如果你想展现风度，可以握着基座持杯，如果你是大众的爱好者呢，你也可以拿着酒杯的杯柄，但切记不要用我们的手去托住酒肚，而使我们葡萄酒改变风味，也不要用我们的手去碰杯沿，这样我们手上的香气会影响你对葡萄酒的判断。</p><h3 id="杯肚与杯沿—倒入酒量"><a href="#杯肚与杯沿—倒入酒量" class="headerlink" title="杯肚与杯沿—倒入酒量"></a>杯肚与杯沿—倒入酒量</h3><p>那么在讲过之后，我们来聊一聊，酒肚是盛放葡萄酒的地方，好的酒杯杯肚，比杯沿宽，因此有足够的空间给研究者转杯，而我们所说的转杯的好处是有利于葡萄酒香气的释放，需要注意的是，倒酒的时候不要超过容量的1/3，也就是到我们酒肚的最大直径处，否则转杯的时候酒液容易洒出，而我们所看到的杯沿呢，是与饮酒者的嘴唇接触的部分，这个部分越薄越好，薄薄的杯沿使酒液更顺畅的进入口中，使饮酒者将更多的注意力，放在品味葡萄酒上，而不是感受酒杯上。</p><h3 id="酒杯的选取"><a href="#酒杯的选取" class="headerlink" title="酒杯的选取"></a>酒杯的选取</h3><p>其实在我们选择一款红葡萄酒杯的时候，我们一定要看它是大肚窄口，而大肚的作用，刚才我说过了，是充分让我们的酒液能够与空气接触，而窄口呢，可以让我们酒液的香气在上升的过程当中凝聚，让我们更好的去品香。葡萄酒的酒杯，有千变万化的种类，他到底有几副面孔呢？</p><p>那么葡萄酒酒杯都有什么类型，我们先来了解一下。</p><ul><li>从工艺上分类分为机器，换机器，半手工，全手工</li><li>按材质分类，分为一般水晶玻璃杯，无铅水晶玻璃杯，还有普通玻璃酒杯</li></ul><p>现在由于我们没有x光射线眼，所以前两种方法只能作为参考，其实在生活中我们常会用到的是形状的分类，这也是最容易识别分类的方法，例如笛形高脚杯(如下图,而右一还可以叫郁金香杯型)，笛型香槟杯最能展现香槟中冉冉上升的气泡的美丽，我们可以看到气泡酒在杯中那美丽的舞蹈，同时我们还能通过笛型香槟杯，来充分的感受。</p><p><img src="http://img.codeagles.com/笛型高脚杯.png" alt=""></p><p>但是呢，我们也常常在好莱坞电影里看到另外一种，可以堆叠香槟塔的浅而宽的短脚香槟杯，其实在这还有一个故事呢，据说这是根据拿破仑的情妇约瑟芬的乳房形状打造的，但因为气泡过快扩散，只用于开庆功宴或婚礼等特殊场合，如果是家庭饮用，还是建议使用笛形高脚香槟杯。</p><p>除了前面说到的这三种方法，还有一种是按功能分类的，从功能的角度又衍生出不同的类型，为葡萄酒增添品尝的视觉享受。我们从功能的角度为大家介绍几种杯型，首先红葡萄酒杯，杯肚宽而杯沿窄，杯子比较高，这样更利于我们刚才所说的转杯。</p><p>而红葡萄酒相对于白葡萄酒来说酒体厚重，单宁物质多，适合用大酒杯，而杯口要略宽一些，大酒杯，杯肚大，杯身也要够长，所以说其实图一中的的左二左三两款呢，都是我们可以选用的葡萄酒杯，如果你要为了闻香，可以选择杯身较长的类型，如果要更好的去品尝杯中的口感，可以选择杯身略窄的杯型。那么为什么市面上咱们见到这样的红酒杯会更多一些呢？其实是因为，这样的红酒杯更适合于我们将鼻子伸进杯口去嗅闻，能够闻到红葡萄酒。能够闻到红葡萄酒浓郁的香气，也更便于香气在红葡萄酒当中的保留，</p><p>而白葡萄酒酒杯，要比红酒杯略小。因为白葡萄酒需要冷却，白葡萄酒一般酒体轻盈，口感清爽，是小清新的类型，所以白葡萄酒杯杯身则更为修长，近乎于U型，杯口也偏小，这样更容易聚集酒的香气，不至于让香气消散得太快。</p><p><img src="http://img.codeagles.com/白葡萄酒酒杯.png" alt="白葡萄酒酒杯"></p><p>甜酒酒杯，也是我们经常会看到的一个类型，甜型葡萄酒的甜度极高，一般搭配餐后甜点，所以所用的杯子会比较小，甜酒的酒杯独特的杯型设计，能够使酒液直接流到舌中部和舌后部，甜味就不会盖过其他的味道了。那么刚才也说过，起泡酒是一款非常美丽可以观赏的葡萄酒类型，那么起泡酒的可贵之处，就在于其细腻持久的气泡，一款起泡漂亮的起泡酒才是好酒，最适合起泡酒的是纤细的郁金香杯形(上图笛型杯中右一)，杯身细长，便于我们观察其美丽的气泡珠环，逐渐收拢的杯口，则有利于保存其起泡酒的香气，闻香时更集中。另外一种是杯身细长的笛形香槟杯，也可称为笛形杯，杯身狭长，是专为香槟而设，当然也适用于其他起泡酒，但其杯口较宽，不利于深入嗅闻，起泡酒的芳香也就不那么完美了，所以在我们品用香槟起泡酒的时候，我们更多的会建议用到郁金香杯形的香槟杯。</p><p>那么还有一种叫白兰地酒杯(如下图)，白兰地是经过蒸馏而得的烈酒，其香气优雅而醇厚，被称为生命之水，白兰地有自己专门的酒杯，是一种大度口的白酒杯，圆胖的杯身有助于白兰地，多接触空气，发展香气，矮脚的设计则为了端酒杯的同时，手掌的温度能够温暖酒液，使白兰地的风味发展更加彻底，狭窄的杯口则有利于保留白兰地的香气，嗅闻香气时香味也更集中。</p><p><img src="http://img.codeagles.com/白兰地酒杯.png" alt="白兰地酒杯"></p><p>到这里我们的酒杯分类就结束了。下一章我们会聊聊如何挑选酒杯。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> 红酒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红酒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手开始ElasticSearch的学习之1ES的配置</title>
      <link href="/2019/04/10/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%BC%80%E5%A7%8BElasticSearch%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B1ES%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/04/10/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%BC%80%E5%A7%8BElasticSearch%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B1ES%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="ES6-7的配置解读-翻译"><a href="#ES6-7的配置解读-翻译" class="headerlink" title="ES6.7的配置解读(翻译)"></a>ES6.7的配置解读(翻译)</h2><blockquote><p>内容是翻译+理解+Google整理出来的，如有问题，请指出，会修正。</p></blockquote><a id="more"></a><h3 id="Start"><a href="#Start" class="headerlink" title="Start"></a>Start</h3><table><thead><tr><th>板块</th><th style="text-align:center">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>集群</td><td style="text-align:center">cluster.name: elasticsearch</td><td style="text-align:left">集群名字，可以自行修改，ES会通过集群名字来区分同一网段下多个集群</td></tr><tr><td>节点</td><td style="text-align:center">node.name: node-1</td><td style="text-align:left">当前节点的节点名字，同一集群下名字不能相同</td></tr><tr><td></td><td style="text-align:center">node.attr.rack: r1</td><td style="text-align:left">比集群更大的概念</td></tr><tr><td></td><td style="text-align:center">node.master: true</td><td style="text-align:left">是否有资格被选举为主节点，该参数默认为true(此版本文件中无该属性)</td></tr><tr><td></td><td style="text-align:center">node.data:true</td><td style="text-align:left">该节点是否为数据节点存储数据，默认为true(此版本文件中无该属性)</td></tr><tr><td>Path路径</td><td style="text-align:center">path.data: /path/to/data</td><td style="text-align:left">存储的数据文件路径，建议设置ES目录外的地方，防止删除时连带文件也被删除</td></tr><tr><td></td><td style="text-align:center">path.logs: /path/to/logs</td><td style="text-align:left">存储的日志文件路径，建议设置ES目录外的地方，防止删除时连带文件也被删除</td></tr><tr><td>内存</td><td style="text-align:center">bootstrap.memory_lock: true</td><td style="text-align:left">这个配置项对node的健康极其重要，JVM永远不swapped out to disk，即永远不使用交换分区将JVM交换到磁盘上。(此条搬运过来，没有亲自尝试过)</td></tr><tr><td>网络</td><td style="text-align:center">network.host: 0.0.0.0</td><td style="text-align:left">默认时，elasticsearch只绑定loopback地址，为了外网访问设置为4个0</td></tr><tr><td></td><td style="text-align:center">http.port: 9200</td><td style="text-align:left">http请求端口 默认9200</td></tr><tr><td>集群发现配置</td><td style="text-align:center">discovery.zen.ping.unicast.hosts: [“host1”, “host2”]</td><td style="text-align:left">例如discovery.zen.ping.unicast.hosts:[“127.0.0.1:9300”,”127.0.0.1:9302”,”127.0.0.1:9304”]</td></tr><tr><td></td><td style="text-align:center">discovery.zen.minimum_master_nodes:</td><td style="text-align:left">为防止数据丢失，配置discovery.zen.minimum_master_nodes设置（默认设置1）至关重要， 以便每个符合主节点的节点都知道 为了形成群集而必须可见的主节点的最小数量，为了防止脑裂要设置多一些主节点节点，建议数量为候选节点/2+1，有三个符合条件的节点，则最小主节点应设置为(3 / 2) + 1或2。</td></tr><tr><td>网关</td><td style="text-align:center">gateway.recover_after_nodes: 3</td><td style="text-align:left">设置集群中N个节点启动时进行数据恢复，默认为3。</td></tr><tr><td>其他</td><td style="text-align:center">action.destructive_requires_name: true</td><td style="text-align:left">删除索引时需要显式名称</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手把手开始ElasticSearch的学习之0ES的搭建</title>
      <link href="/2019/04/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%BC%80%E5%A7%8BElasticSearch%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B0ES%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/04/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%BC%80%E5%A7%8BElasticSearch%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B0ES%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="搭建Elasticsearch环境"><a href="#搭建Elasticsearch环境" class="headerlink" title="搭建Elasticsearch环境"></a>搭建Elasticsearch环境</h2><p>[TOC]</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Elasticsearch是一个基于ApacheLucene(TM)的开源搜索引擎。无论在开源还是专有领域，Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库。 </p><p>但是Lucene的使用不太友好，而Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，对Lucene的有友好的封装，开箱即用。废话不多说，优势劣势网上论调一堆，而这里需要先让他跑起来，强大之处以后慢慢在发现吧。 </p><a id="more"></a><h3 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h3><p>本文基于CentOS7下进行的，要求至少2GB内存，JDK、ES(版本自行选择) </p><h4 id="安装JDK1-8"><a href="#安装JDK1-8" class="headerlink" title="安装JDK1.8"></a>安装JDK1.8</h4><p>一、下载 </p><p>首先<a href="https://www.oracle.com/technetwork/cn/java/javase/downloads/jdk8-downloads-2133151-zhs.html" target="_blank" rel="noopener">官网下载</a>JDK，按照自己需要的版本下载，这里选择的是jdk-8u181-linux-x64.tar.gz包，然后将包上传到服务器中 </p><p>二、解压&amp;安装&amp;配置&amp;校验完成 (路径按照个人习惯选择) </p><ol><li>建立文件夹并将jdk移动到文件夹中 </li></ol><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> /usr/<span class="built_in">local</span>/java</span><br></pre></td></tr></table></figure><ol start="2"><li>解压下载的jdk包 </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/java </span><br><span class="line"></span><br><span class="line">tar -zxvf jdk-8u181-linux-x64.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压后可以删除该文件 </span></span><br><span class="line"></span><br><span class="line">rm -rf jdk-8u181-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><ol start="3"><li>配置环境变量 </li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 设置全局变量 </span></span><br><span class="line"></span><br><span class="line">vim <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure><ol start="4"><li>在文件末尾追加 </li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">JAVA_HOME=<span class="regexp">/usr/local</span><span class="regexp">/java/jdk</span>1.<span class="number">8.0_201</span> </span><br><span class="line"></span><br><span class="line">JRE_HOME=<span class="regexp">/usr/local</span><span class="regexp">/java/jdk</span>1.<span class="number">8.0_201</span>/jre </span><br><span class="line"></span><br><span class="line">CLASSPATH=.:$JAVA_HOME/<span class="class"><span class="keyword">lib</span>/<span class="title">dt</span>.<span class="title">jar</span>:$<span class="title">JAVA_HOME</span>/<span class="title">lib</span>/<span class="title">tools</span>.<span class="title">jar</span>:$<span class="title">JRE_HOME</span>/<span class="title">lib</span> </span></span><br><span class="line"></span><br><span class="line">PATH=$JAVA_HOME/<span class="symbol">bin:</span>$PATH </span><br><span class="line"></span><br><span class="line">export PATH JAVA_HOME CLASSPATH</span><br></pre></td></tr></table></figure><ol start="5"><li>更新文件使其生效 </li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#退出编辑模式后 </span></span><br><span class="line"></span><br><span class="line">source <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure><ol start="6"><li>校验 </li></ol><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 输入命令校验 </span></span><br><span class="line"></span><br><span class="line">java -<span class="built_in">version</span></span><br></pre></td></tr></table></figure><p>出现下图则安装成功 </p><p><img src="http://img.codeagles.com/校验java.png" alt="检验环境变量"> </p><h4 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h4><p>一、<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener">官网下载</a>选择适合的版本 </p><p>二、解压&amp;安装 (路径按照个人习惯选择) </p><ol><li>创建存放文件夹并解压 </li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># 创建目录 </span></span><br><span class="line"></span><br><span class="line">mkdir <span class="meta-keyword">/usr/</span>lcoal<span class="meta-keyword">/es/</span> </span><br><span class="line"></span><br><span class="line">cd <span class="meta-keyword">/usr/</span>local/es </span><br><span class="line"></span><br><span class="line"><span class="meta"># 解压es包 </span></span><br><span class="line"></span><br><span class="line">tar -zxvf elasticsearch<span class="number">-6.7</span><span class="number">.1</span>.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="meta"># 解压后可以删除该文件 </span></span><br><span class="line"></span><br><span class="line">rm -rf elasticsearch<span class="number">-6.7</span><span class="number">.1</span>.tar.gz</span><br></pre></td></tr></table></figure><ol start="2"><li>进入解压后的文件夹 </li></ol><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 进入cd elasticsearch-&lt;version&gt; </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cd</span> elasticsearch-6.7.1 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行启动 </span></span><br><span class="line"></span><br><span class="line"><span class="string">./bin/elasticsearch</span></span><br></pre></td></tr></table></figure><p><strong>此时执行完会报错，这是因为es是不能采用root用户启动的，所以需要切换非root用户启动</strong> </p><p><img src="http://img.codeagles.com/es启动报错.png" alt="es启动"> </p><p>三、建立新用户启动es </p><ol><li>为用户先建立一个用户组 </li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">groupadd searchgroup</span></span><br></pre></td></tr></table></figure><ol start="2"><li>创建用户并加入用户组 </li></ol><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># 方式一 直接创建并加入组 </span></span><br><span class="line"></span><br><span class="line">useradd -g searchgroup searcher </span><br><span class="line"></span><br><span class="line"><span class="meta"># 方式二 先创建，在加入组 </span></span><br><span class="line"></span><br><span class="line">useradd searcher </span><br><span class="line"></span><br><span class="line">usermod -G searchgroup searcher</span><br></pre></td></tr></table></figure><ol start="3"><li>给目标用户授权文件夹权限&amp;切换用户 </li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#授权文件夹权限 </span></span><br><span class="line"></span><br><span class="line">chown -R searcher:searchgroup <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/es/</span>elasticsearch<span class="number">-6.7</span><span class="number">.1</span>/ </span><br><span class="line"></span><br><span class="line"><span class="meta">#切换用户 </span></span><br><span class="line"></span><br><span class="line">su searcher</span><br></pre></td></tr></table></figure><ol start="4"><li>执行es启动 </li></ol><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">cd <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/es/</span>elasticsearch<span class="number">-6.7</span><span class="number">.1</span>/ </span><br><span class="line"></span><br><span class="line"><span class="meta"># 启动 </span></span><br><span class="line"></span><br><span class="line">.<span class="meta-keyword">/bin/</span>elasticsearch</span><br></pre></td></tr></table></figure><p><strong>tips: ./bin/elasticsearch 后面可选参数 -d 表示守护进程启动，也就是后台启动，如果不加该参数，当ctrl+c停止的时候，es服务也就停止了。</strong> </p><p>四、测试 </p><p>如果非守护进行启动，可以直接看到启动日志；若守护进程启动，可以在日志文件夹中进行查看。 </p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># 进入日志文件夹 </span></span><br><span class="line"></span><br><span class="line">cd /usr/<span class="keyword">local</span>/es/elasticsearch<span class="number">-6.7</span><span class="number">.1</span>/logs </span><br><span class="line"></span><br><span class="line"><span class="meta">#查看启动日志 </span></span><br><span class="line"></span><br><span class="line">tail -<span class="function"><span class="keyword">fn</span> <span class="number">300</span> elasticsearch.<span class="built_in">log</span></span></span><br></pre></td></tr></table></figure><p>日志出现该信息，启动完成 </p><p><img src="http://img.codeagles.com/es启动成功.png" alt="日志"> </p><p>在本机访问检验，出现以下信息即为启动成功 </p><p><img src="http://img.codeagles.com/es校验.png" alt="访问"> </p><p><em>小彩蛋：在以前的低版本中，上述显示es版本信息的时候，name字段是一个随机的漫威名字英雄名字</em> </p><p>至此，整个环境搭建就结束了。 </p><h3 id="外网访问"><a href="#外网访问" class="headerlink" title="外网访问"></a>外网访问</h3><p>现在搭建好的ES，只能通过服务器内部或者说是本机访问，如果想在外网访问该怎么做呢？ </p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>进入到config目录<code>/usr/local/es/elasticsearch-{version}/config</code> </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">vim</span> <span class="selector-tag">elasticsearch</span><span class="selector-class">.yml</span></span><br></pre></td></tr></table></figure><p>在文件中找到<code>network.host</code> 去掉注释并修改值为<code>0.0.0.0</code>, 去掉<code>http.port</code> </p><p>的注释，默认http端口9200，可以根据自行需要修改。修改完成后重启es。 </p><p>成功后，在浏览器中访问<code>http://你的公网ip:9200/</code>就会展示出es的版本信息，与上图成功的信息一样。 </p><h4 id="浏览器插件"><a href="#浏览器插件" class="headerlink" title="浏览器插件"></a>浏览器插件</h4><p>卖个关子，服务器搭建完成了，想在自己的机器上Win/Mac等访问服务器的ES服务，查看数据怎么办呢？搜索了一圈会发现大家都提到了<code>elasticsearch-head</code>这个插件，折腾一番安装、启动、访问等等终于出现了可视化界面。但是每次想连接ES都要走这么一个流程，这里推荐另一个替代品-Chrome插件，超级棒。 </p><p><img src="http://img.codeagles.com/Chrome插件.jpg" alt="Chrome插件"> </p><p>安装之后 </p><p><img src="http://img.codeagles.com/es效果图.png" alt=""> </p><p>搞定。 </p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>Q：./bin/elasticsearch 启动报错<code>can not run elasticsearch as root</code> </p></li><li><p>A: 切换用户启动，具体操作请看文中解决办法 </p></li><li><p>Q：启动时报错` </p></li></ul><p>max virtual memory areas vm.maxmapcount [xxxxx] is too low` </p><ul><li>A: 执行命令 ` </li></ul><p>sudo sysctl -w vm.max_map_count=262144` </p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客目录</title>
      <link href="/2019/03/27/%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/"/>
      <url>/2019/03/27/%E5%8D%9A%E5%AE%A2%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="博客目录"><a href="#博客目录" class="headerlink" title="博客目录"></a>博客目录</h2><blockquote><p>持续更新目录，个人会根据功能和内容进行手动分类。可根据右侧“本文目录进行速度定位查看”</p></blockquote><a id="more"></a><hr><h3 id="红酒入门系列"><a href="#红酒入门系列" class="headerlink" title="红酒入门系列"></a>红酒入门系列</h3><blockquote><p>从了解红酒开始，逐渐到餐桌礼仪、饮食搭配等等</p></blockquote><h6 id="1-红酒入门系列之红酒起源"><a href="#1-红酒入门系列之红酒起源" class="headerlink" title="1. 红酒入门系列之红酒起源"></a>1. <a href="https://codeagles.com/2019/01/13/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BA%A2%E9%85%92%E8%B5%B7%E6%BA%90/" target="_blank" rel="noopener">红酒入门系列之红酒起源</a></h6><h6 id="2-红酒入门系列之酿造"><a href="#2-红酒入门系列之酿造" class="headerlink" title="2. 红酒入门系列之酿造"></a>2. <a href="https://codeagles.com/2019/01/13/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%85%BF%E9%80%A0/" target="_blank" rel="noopener">红酒入门系列之酿造</a></h6><h6 id="3-红酒入门系列之葡萄酒的分类"><a href="#3-红酒入门系列之葡萄酒的分类" class="headerlink" title="3. 红酒入门系列之葡萄酒的分类"></a>3. <a href="https://codeagles.com/2019/03/17/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E8%91%A1%E8%90%84%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/" target="_blank" rel="noopener">红酒入门系列之葡萄酒的分类</a></h6><h6 id="4-红酒入门系列之酒杯的分类"><a href="#4-红酒入门系列之酒杯的分类" class="headerlink" title="4. 红酒入门系列之酒杯的分类"></a>4. <a href="https://codeagles.com/2019/05/03/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%85%92%E6%9D%AF%E7%9A%84%E5%88%86%E7%B1%BB/" target="_blank" rel="noopener">红酒入门系列之酒杯的分类</a></h6><h6 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h6><hr><h3 id="手把手开始ElasticSearch系列"><a href="#手把手开始ElasticSearch系列" class="headerlink" title="手把手开始ElasticSearch系列"></a>手把手开始ElasticSearch系列</h3><blockquote><p>从ES的搭建到简单使用，进入到在项目中集成ES，并结合SpringBoot项目集成JPA方式使用ES的基础操作</p></blockquote><h6 id="1-手把手开始ElasticSearch的学习之0-ES的搭建"><a href="#1-手把手开始ElasticSearch的学习之0-ES的搭建" class="headerlink" title="1. 手把手开始ElasticSearch的学习之0 ES的搭建"></a>1. <a href="https://codeagles.com/2019/04/09/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%BC%80%E5%A7%8BElasticSearch%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B0ES%E7%9A%84%E6%90%AD%E5%BB%BA/" target="_blank" rel="noopener">手把手开始ElasticSearch的学习之0 ES的搭建</a></h6><h6 id="2-手把手开始ElasticSearch的学习之1-ES的配置"><a href="#2-手把手开始ElasticSearch的学习之1-ES的配置" class="headerlink" title="2. 手把手开始ElasticSearch的学习之1 ES的配置"></a>2. <a href="https://codeagles.com/2019/04/10/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%BC%80%E5%A7%8BElasticSearch%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B9%8B1ES%E7%9A%84%E9%85%8D%E7%BD%AE/" target="_blank" rel="noopener">手把手开始ElasticSearch的学习之1 ES的配置</a></h6><h6 id="待更新-1"><a href="#待更新-1" class="headerlink" title="待更新"></a>待更新</h6><hr>]]></content>
      
      
      <categories>
          
          <category> 目录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红酒入门系列之葡萄酒的分类</title>
      <link href="/2019/03/17/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E8%91%A1%E8%90%84%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/"/>
      <url>/2019/03/17/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E8%91%A1%E8%90%84%E9%85%92%E7%9A%84%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="三、葡萄酒的分类"><a href="#三、葡萄酒的分类" class="headerlink" title="三、葡萄酒的分类"></a>三、葡萄酒的分类</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家在喝葡萄酒的时候都会挑一挑，那到底在挑什么呢？(挑价格的…我竟无法反驳)，一般来说看看产区、葡萄品种、酒精度等等，那么其实就是在认识葡萄酒的分类，今天就整理一下分类的小知识吧。</p><blockquote><p>根据国际葡萄与葡萄酒组织的规定，葡萄酒只能是破碎或为破碎的新鲜葡萄果实或葡萄汁经完全或部分酒精发酵后获得的饮料，且酒精度一般不低于8.5°</p></blockquote><a id="more"></a><h2 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h2><p>根据上篇酿造葡萄酒工艺的时候提到了，葡萄酒可以按照颜色区分，一般分为三类：</p><ul><li>红葡萄酒</li><li>白葡萄酒</li><li>少女杀手-桃红葡萄酒</li></ul><p><img src="http://img.codeagles.com/葡萄酒.jpg" alt="按照颜色分类的葡萄酒"></p><h2 id="品种"><a href="#品种" class="headerlink" title="品种"></a>品种</h2><p>全世界的酿酒的葡萄大致分为两种：红葡萄品种和白葡萄品种。而产区的环境因素也是葡萄产生了千差万别的风格。例如来自美国加州温暖地区的赤霞珠和法国凉爽潮湿地区的赤霞珠，口感就不大一样。</p><h2 id="是否混酿"><a href="#是否混酿" class="headerlink" title="是否混酿"></a>是否混酿</h2><ul><li>单一酿造</li><li>不同品种的混酿</li></ul><p>单一酿造的葡萄酒，风格较为稳定。而不同品种混酿的葡萄酒香气和风格就多种多样了，最出名的就是大家熟知的法国波尔多地区的混酿葡萄酒。</p><h2 id="酿酒师"><a href="#酿酒师" class="headerlink" title="酿酒师"></a>酿酒师</h2><p>几乎每个酿酒师，都有自己独特的酿酒风格，这些都会影响葡萄酒的风格。当然也有多个酿酒师共同酿造的葡萄酒，一般都是打造那种旗舰葡萄酒。</p><p>区分葡萄酒的方式多种多样，除了以上的方式，还有一些其他的方式，有一些也是现在较为流行的区分方法。</p><h2 id="是否过桶"><a href="#是否过桶" class="headerlink" title="是否过桶"></a>是否过桶</h2><p>葡萄酒是否在新橡木桶中熟化或者陈年，这会对葡萄酒口感产生明显的口感，橡木桶会增加红葡萄酒中单宁，从而增加葡萄酒的酒气、口感的复杂度。没有经过橡木桶的葡萄酒一般以果香为主。</p><h2 id="是否陈年"><a href="#是否陈年" class="headerlink" title="是否陈年"></a>是否陈年</h2><p>这个方式我们既熟悉又陌生。葡萄酒是否陈年以及陈年时间长短都会对葡萄酒品质和口感产生一定的影响，对于红葡萄酒一般来是说，陈年时间长的呢，酒体会更丰满，风味也更为复杂。</p><h2 id="含糖量区分"><a href="#含糖量区分" class="headerlink" title="含糖量区分"></a>含糖量区分</h2><p>其实含糖量区分，说白了就是我们对葡萄酒的口感区分，这也是很直接的区分方式，那么这样来看会分为四种，干型、半干型、半甜型以及甜型。</p><ul><li>干型：含糖量为4g/L以下。指葡萄汁中糖分完全转化酒精，残留糖分含糖量在每升4克以下，这种酒品尝起来没有甜味，只有酸味和清爽的那种感觉。当然也因为口感的问题，不易于我们接受。</li><li>半干型：含糖量为4~12g/L。</li><li>半甜型：含糖量为12~45g/L，这种也是目前被消费最多的葡萄酒。</li><li>甜型：含糖量为45g/L以上，这种酒已经在口中可以明显感受到甜味了</li></ul><h2 id="是否有气泡"><a href="#是否有气泡" class="headerlink" title="是否有气泡"></a>是否有气泡</h2><p>按照这个方式来分，可以分为两种，一种是静止葡萄酒，一种是起泡葡萄酒。</p><ul><li>静止葡萄酒：20℃时，二氧化碳量在0.5bar</li><li>气泡葡萄酒：20℃时，二氧化碳量在3.5bar</li></ul><p>说白了，把酒倒杯子里面看看酒体中有没有小气泡就好了。</p><h2 id="酿造方法"><a href="#酿造方法" class="headerlink" title="酿造方法"></a>酿造方法</h2><p>这是最后一种区分方法就是按照酿造方法来区分。</p><ul><li>完全用葡萄做为原料发酵</li><li>特种葡萄酒<ul><li>加强葡萄酒</li><li>冰葡萄酒</li><li>贵腐葡萄酒</li></ul></li></ul><p>一种是完全用葡萄作为原料发酵而成，不添加任何酒精、香料以及糖分的葡萄酒。</p><p>另一种是特种葡萄酒，是指用新鲜葡萄或葡萄汁在采摘和酿造工艺中使用的特殊方式酿造的葡萄酒。这其中又分为加强型葡萄酒，在天然葡萄酒中加入蒸馏酒，一般为白兰地，酒精度在15°~20°的葡萄酒，例如我们常听到的波特酒。而另一种是冰葡萄酒，当气温低于-8℃时结冰状态下采摘，带冰压榨进行酿造的葡萄酒。还有一种是贵腐葡萄酒，它是在葡萄成熟后期果实感染了贵腐霉菌，使果实成分发生了明显变化，之后进行酿造的，这里有苏玳甜酒就是例子。</p><p>小tips:蒸馏葡萄酒通常称为白兰地，XO就是我们所说的白兰地。加强型葡萄酒则需要添加芳香型的葡萄酒。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说了这么多分类，上哪能记住啊，喝个酒还这么费劲。其实简单记忆，最常用的方式也是我们使用最多的方式，按颜色区分、按含糖量区分以及按是否有气泡区分即可。这么多的方式，无外乎是为了我们在挑选时，给我们多一些指向性的信息，最重要的是多尝试不同种类，挑选出适合自己的葡萄酒才是我们目的。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> 红酒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红酒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL分组排序取前N条记录</title>
      <link href="/2019/02/14/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2019/02/14/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL分组排序取前N条记录"><a href="#MySQL分组排序取前N条记录" class="headerlink" title="MySQL分组排序取前N条记录"></a>MySQL分组排序取前N条记录</h2><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>找到每组中数量最大的前两名。</p><p>测试数据表字段为编号、姓名、数量以及小组编号</p><a id="more"></a><p>现有数据表及其数据：</p><p><img src="http://img.codeagles.com/%E6%95%B0%E6%8D%AE%E8%A1%A8.jpg" alt="数据表"></p><h4 id="直接抛出结果："><a href="#直接抛出结果：" class="headerlink" title="直接抛出结果："></a>直接抛出结果：</h4><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *  <span class="keyword">FROM</span> <span class="symbol">`test`</span> t</span><br><span class="line"><span class="keyword">where</span> <span class="number">2</span> &gt; (</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(a.num) <span class="keyword">from</span> test a </span><br><span class="line"><span class="keyword">where</span> a.cid =  t.cid</span><br><span class="line"><span class="keyword">and</span> a.num &gt; t.num</span><br><span class="line">)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t.cid <span class="keyword">asc</span>, t.num <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure><p><img src="http://img.codeagles.com/%E7%BB%93%E6%9E%9C%E8%A1%A8.jpg" alt="结果集"></p><p>解析：<br>主要是 <strong>2&gt;(select count(a.num) from test a where a.cid =  t.cid and a.num &gt; t.num )</strong> 这句话,把数据表 作为两个表进行数据对比，用数据表cid为2的数据结合sql举例。</p><p>相当于有两个表分别为主表t和a，且里面的数量都是6000,8000,7500。而sql中<strong>a.num &gt; t.num a.num &gt; t.num</strong>,则表示用当前t表记录跟a表记录分别对比，分步分析如：</p><ul><li>第一步：t.6000 对比 a中的(6000,8000,7500) 是否满足 a.num &gt; t.num,</li><li>结果是a中有两条记录大于t.6000</li><li>count(a.num)的值 等于2，不满足 2 &gt;( count值 ) 故弃之</li></ul><ul><li>第二步 t.8000 对比 a中的(6000,8000,7500) 是否满足 a.num &gt; t.num,</li><li><ul><li>结果是a中没有记录大于 t.8000</li></ul></li><li>count(a.num)的值 等于0，满足 2 &gt;( count值 ) 故留之</li></ul><ul><li>第三步 t.7500 对比 a中的(6000,8000,7500) 是否满足 a.num &gt; t.num,</li><li>结果是a中有1条记录大于 t.7500</li><li>count(a.num)的值 等于1，满足 2 &gt;( count值 ) 故留之</li></ul><p>结果即为t.8000,t.7500两条记录。其他的就好理解了。这里还有个需求变化，上述SQL是查表中num最大的前两条，是不包括重复的，如果数据为8000,6000,6000，结果为8000,6000，对于6000的数据取的哪个值，取决于排序。说白了上述SQL只取两条数据。</p><p>而还有一种需求是，取整体数量的最大的两个值，如果重复按照重复显示出来，比如8,6,6 那么最大的两个数字即为8和6，结果集应为8,6,6三条记录，而这个变换写法，就是在 <strong>(select count(a.num) from test a where a.cid =  t.cid and a.num &gt; t.num )</strong> 这个时候对数据去重，改为 <strong>count(distinct a.num)</strong> 即可.</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>书单</title>
      <link href="/2019/02/13/%E4%B9%A6%E5%8D%95/"/>
      <url>/2019/02/13/%E4%B9%A6%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><blockquote><p>如果莫名其妙地烦躁，要么是没怎么读书，要么是没怎么锻炼，或者两者都没做到</p></blockquote><a id="more"></a><h3 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h3><ol><li>《你一年的8760小时(升级版)》—艾力</li><li>《如何阅读一本书》</li><li>《如何成为一个有趣的人》</li><li>《如何高效学习：一年完成麻省理工4年33门课程的整体学习法》</li><li>《流浪地球》</li><li>《富爸爸财务自由之路》</li></ol><p>听书：</p><ol><li>OKR工作法</li><li>睡眠革命</li><li>刻意练习</li><li>人生效率手册</li><li>高效能人士的七个习惯</li><li>深度工作</li><li>思辨与立场</li></ol><h3 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h3><ol><li>《淘宝技术这十年》 </li><li>《高倍速阅读法》 </li><li>《Finding Nemo》英文原版––海底总动员 </li><li>《Zootopia》英文原版––疯狂动物城 </li><li>《Big Hero 6》英文原版––超能陆战队 </li><li>《极客生活：我的第一本科学生活用书》</li><li>《从0到1：开启商业与未来的秘密》</li><li>《蓝筹孩子》 </li><li>《CoCo》英文原版––寻梦环游记 </li><li>《富甲美国》 </li><li>《小狗钱钱》 </li></ol>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> 书籍 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红酒入门系列之酿造</title>
      <link href="/2019/01/13/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%85%BF%E9%80%A0/"/>
      <url>/2019/01/13/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E9%85%BF%E9%80%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="二、葡萄酒的酿造"><a href="#二、葡萄酒的酿造" class="headerlink" title="二、葡萄酒的酿造"></a>二、葡萄酒的酿造</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家吃葡萄时都会想起一个绕口令，吃葡萄不吐葡萄皮……皮，我舌头打结了，就先不说了。为什么提这个呢，实际上葡萄皮的营养非常之多，而且酿造葡萄酒的关键也就是在这个葡萄皮上。</p><a id="more"></a><h2 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h2><p>葡萄酒按照颜色大众选择，一般分为三类：</p><ul><li>红葡萄酒</li><li>白葡萄酒</li><li>少女杀手-桃红葡萄酒</li></ul><p><img src="http://img.codeagles.com/葡萄酒.jpg" alt="按照颜色分类的葡萄酒"></p><p>不禁想问一下，同样都是葡萄，怎么你就那么优秀呢？而且大家知道，葡萄的果肉榨出来的汁几乎是没有颜色的，怎么就会出现这样的差异呢？哎！？真相只有一个，问题出在了葡萄皮的身上。红葡萄酒酿造时是连同葡萄皮一起发酵，皮中的色素也大都进入到了酒液当中，而白葡萄酒则是去皮发酵，那么桃红葡萄酒呢，也是连皮一起发酵与红葡萄酒类似，只不过在浸皮的时间上要比红葡萄酒短了很多很多。一般来说红葡萄酒是用红葡萄品种来酿造的，白葡萄酒是用白葡萄品种酿造的，当然这句看起来像句废话，实际上白葡萄酒也可以是红葡萄品种去皮发酵的。</p><h2 id="酿造工艺"><a href="#酿造工艺" class="headerlink" title="酿造工艺"></a>酿造工艺</h2><p>总是听说葡萄酒都是脚丫子踩出来的，导致喝的时候总会脑补画面，后来接触了红酒文化，才知道。。。果真有这么一说，但是放心，不是那种脑补画面的脚，这里是一种传统古法的一种萃取方式。想了解这个，就要说回到葡萄酒的酿造过程了。</p><p>葡萄酒的质量取决于葡萄质量，而葡萄质量则是由多种因素影响着，比如天气、土壤等等，葡萄采摘时也特别看天气，天气要是不好，可能一整园的葡萄酒白白牺牲了。葡萄的采摘分为人工采摘和机械采摘，当然机器采摘的成本很低了，机器采摘后工人们要对葡萄进行筛选，去叶去叶柄以及坏掉的葡萄，筛选后的葡萄经由去梗机去梗，然后传送到贮存器，最后被送到发酵器皿中进行发酵。</p><p>红葡萄酒与白葡萄酒的酿造过程中，最大的区别就在这产生了，红葡萄酒在发酵的时候，葡萄会带皮发酵，而酿造白葡萄酒时，葡萄会在发酵之前先进行压榨去皮处理。而刚刚说的用脚踩的方式就是红葡萄酒发酵过程的一道工序，葡萄牙杜罗河产区的一种发酵器皿，由花岗岩大理石水泥或不锈钢制成的浅底无盖大桶，把葡萄加入进去后用脚踩踏，让葡萄充分破碎以萃取葡萄皮的颜色和单宁以及其他风味物质。</p><p>红葡萄酒与白葡萄酒的区别在于，红葡萄酒要通过浸皮的方式来萃取葡萄皮中的色素和单宁，将破碎的葡萄与葡萄汁一起浸泡。在浸皮的过程一起发酵，糖分在酵母的作用下转化为酒精。红葡萄发酵温度比白葡萄酒温度略高一些，大约在25℃到30℃之间，这样能更快萃取葡萄皮中的色素和单宁，发酵时间在2~4周，发酵完成后，需要将葡萄酒和酒糟分离开，葡萄酒一般会在橡木桶中继续沉淀放置一段时间，而橡木桶可以使葡萄酒口感变得更柔顺、气味更香醇，这也有可能为什么人们中执着于葡萄酒经没经过橡木桶发酵的原因了。</p><blockquote><p>这座城市天生就适合恋爱，而我天生就适合你的灵魂。——杜拉斯</p></blockquote><p>这句话就像橡木桶与葡萄酒的关系。橡木桶发酵过程中，橡木桶中的香草酚和丁子香酚含量会提高，会给予葡萄酒烟熏、肉桂、焦糖等等的响起，这些味道的融合也就是我们常说的橡木桶味道了。而橡木桶还有另一个重要的作用，就是控制氧气。酿酒师们通过控制微量的氧化，来加强葡萄酒的结构和复杂程度的目的，所以使用橡木桶来酿造的葡萄酒，往往拥有更加复杂的口感，味道层次上也会更加丰富。</p><h2 id="橡木桶中的轮回"><a href="#橡木桶中的轮回" class="headerlink" title="橡木桶中的轮回"></a>橡木桶中的轮回</h2><p>经过橡木桶陈酿的葡萄酒，在颜色上会有很多变化。</p><ul><li>干白葡萄酒：经过长时间的陈年后，颜色会逐渐成为琥珀色，在光线的投射下没有反射。</li><li>干红葡萄酒：经过长时间的陈年后，颜色会渐渐加深，陈年过程中橡木桶的单宁与葡萄的单宁结合，是葡萄酒更精细、口感顺滑。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> 红酒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红酒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红酒入门系列之红酒起源</title>
      <link href="/2019/01/13/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BA%A2%E9%85%92%E8%B5%B7%E6%BA%90/"/>
      <url>/2019/01/13/%E7%BA%A2%E9%85%92%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BA%A2%E9%85%92%E8%B5%B7%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一、葡萄酒的起源"><a href="#一、葡萄酒的起源" class="headerlink" title="一、葡萄酒的起源"></a>一、葡萄酒的起源</h1><h2 id="瞎聊一下"><a href="#瞎聊一下" class="headerlink" title="瞎聊一下"></a>瞎聊一下</h2><p>我比较爱喝红酒，当时就是单纯的喜欢喝，后来就很想学习红酒文化，所以从方方面面学习过、了解过红酒的一些基本知识，虽说不上有多专业，但是多少还是知道些大概。当然好酒都是比较贵的，我也负担不起那么多钱(毕竟家里没矿),不过普通餐酒什么的还是没少喝的，当然我相信大多数人对红酒的概念就是—逼格高。同学、朋友聚会，一喝红酒就觉得要开始装X了。既然如此，我打算将我自己学习的、了解的整理出来，分享出来，至少在装X的时候有点货。那么接下来我要装X了，哦不，开始梳理了。</p><a id="more"></a><h2 id="葡萄酒起源"><a href="#葡萄酒起源" class="headerlink" title="葡萄酒起源"></a>葡萄酒起源</h2><p>对于葡萄酒的起源，各种资料上、古籍记载都各不相同，据说早在一万年前，葡萄酒是自然发酵的产物，在葡萄果粒成熟后落到地上，果皮破裂，渗出的果汁与空气中的酵母菌接触后不久，最早的葡萄酒就产生了，这里就有一个故事了。</p><blockquote><p>圣经中创世纪第八、九章说道一个诺亚醉酒的故事：诺亚是亚当与夏娃无数子孙中的一个男人，十分的虞城信奉上帝，他也就成为了后来人的始祖。当上帝发现了世上出现了邪恶和贪婪后，决定在地球上发一场大洪水，来清除所有的罪恶的生灵。诺亚遵循主的旨意，挑选地球上所有的植物(他挑选的植物就是葡萄)、动物种各一对雌雄，带着自己的3个儿子(西姆Sem、可汗 Coham和迦费特Japhet)，登上了自制的木船，即著名的诺亚方舟。经过150天的洪水淹没后，在第七个月零17天，方舟被搁在了阿拉拉特山上(土耳其东部，亚美尼亚共和国与伊朗交界的边境地区)。此后，诺亚开始耕作土地，并种下了第一株葡萄植株，后来又着手酿酒。一天，他一人在帐篷里独自开怀豪饮，烂醉如泥。他的儿子可汗发现诺亚赤身裸体的醉躺在地上后，叫来了西姆和迦费特，后两人拿着长袍，倒退着进帐篷背着面给父亲盖上，没有看父亲裸露的身体。诺亚酒醒后，就诅咒可汗，要神让可汗的儿子迦南一族做迦费特家族的奴隶。自己酒后失礼，却迁怒于儿子，更有甚者，还要罚自己的孙子为奴。“酒后无德”，看来古今中外都是一样的。</p></blockquote><p>那么最早真正有记载的葡萄酒起源于古代波斯，也就是现在的伊朗，随着战争传入到其他国家，后来等到哥伦布发现新大陆后，西班牙和葡萄牙的殖民者、传教士在十六世纪将欧洲的葡萄品种带到南美洲，后来，英国人试图将葡萄栽培技术传入美洲大西洋沿岸，但是气候等等原因失败了。直到后面十九世纪中期，有了嫁接技术葡萄酒业才慢慢发展起来。</p><p>但是发现不管何时，葡萄酒始终没有进入到国门，那什么时候才传入到的中国呢，实际上远在中国古代就有了葡萄酒，只是当时仅限贵族引用，普通老百姓是喝不到的，到了唐朝才算是真正的大肆流行起来。而葡萄酒是怎么来到我们中原的呢，可能大家想到了一个人，就是张骞，张骞出使西域的故事大家并不陌生，据史书记载，西汉建元三年（公元前138年）张骞奉汉武帝之命，出使西域，当时看到一堆一坨一坨的酒鬼喝的是五体投地，遍地还都是酒坛子，就好奇问这玩意是啥，得知了是葡萄酒，张骞心想，“呦，不错呦”，然后将葡萄引进中国开始种植，不过虽然当时古代其他周边国家都有酿造技术的，但如蟹皇堡的秘方一样都是机密，根本不外传，中原真正点了酿造这个技能点的时候是唐朝的事情了，这得益于一个叫高昌的西域国家，唐朝破了高昌国后，收集到马乳葡萄(马奶予葡萄)放到院中，自然也获得了酿酒的技术，唐太宗把技术资料作了修改后酿出了芳香酷烈的葡萄酒，和大臣们共同品尝。慢慢的普及到了民间，葡萄酒也被当成陪嫁的嫁妆等等，胡人还在长安开设了酒庄贩卖，在慢慢的就发展起来。</p><p>说到这，大家可能对葡萄酒的起源大致了解了一些，当然葡萄酒还有很多妙处，李时珍在《本草纲目》中也指出：“葡萄酒……驻颜色，耐寒。”，说明葡萄酒有药用价值，增强人体健康，当然即使这样的酒，也不可贪杯呦。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> 红酒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红酒 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之算法时间复杂度</title>
      <link href="/2018/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2018/12/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>版权声明：本文为 Codeagles 原创文章，可以随意转载，但必须在明确位置注明出处！！！</p></blockquote><p>想要学会算法时间复杂度，那么就要先弄清楚几个概念。</p><ol><li>什么是算法时间复杂度？</li><li>它有什么用呢？</li><li>写法记作 T(n)=O(f(n))<ul><li>T(n):语句执行的总次数关于n的函数</li><li>n：问题规模</li><li>f(n):问题规模n的某个函数</li><li>用O()来体现算法时间复杂度的记法</li></ul></li></ol><a id="more"></a><p>时间复杂度的定义是：如果一个问题的规模是n，解决这一问题所需算法所需要的时间是n的一个函数T(n)，则T(n)称为这一算法的时间复杂度。<br>所谓算法时间复杂度就是一句话：<strong>算法中基本操作的执行次数。</strong>既然是T(n)的函数，随着模块n的增大，算法执行的时间的增长率和T(n)的增长率成正比，所以T(n)越小，算法的时间复杂度越低，算法的效率越高。</p><p>那么它有什么用呢？刚才也说了，可以通过f(n)的函数关系来评估算法的效率问题，说白了就是<strong>通过时间复杂度来看算法的好坏</strong>。</p><p><em>值得注意的是：有的算法中基本操作执行次数不仅仅跟初始输入的数据规模(n)有关，还和数据本身有关。例如一些排序算法，同样n个待处理数据，数据初始有序性不同，基本操作执行次数也会不同。如果算法中有特殊要求，一般依照使得基本操作执行次数最多的输入来计算时间复杂度，即将最坏的情况最为算法时间复杂度的度量。</em></p><h1 id="常见的是按复杂度的大小"><a href="#常见的是按复杂度的大小" class="headerlink" title="常见的是按复杂度的大小"></a>常见的是按复杂度的大小</h1><p><img src="http://img.codeagles.com/时间复杂度.png" alt="常见的时间复杂度"><br>有的人会对log2 n与log n做对比，不理解这里为什么不一样，其实这两个是一样的也就是图中第2个和第4个都是可以替换以2为底的对数形式。</p><p><em>对数时间<br>主条目：对数时间<br>若算法的T(n) = O(log n)，则称其具有对数时间。由于计算机使用二进制的记数系统，对数常常以2为底（即log2 n，有时写作lg n）。然而，由对数的换底公式，loga n和logb n只有一个常数因子不同，这个因子在大O记法中被丢弃。因此记作O（log n），而不论对数的底是多少，是对数时间算法的标准记法。————维基</em></p><h1 id="如何计算或者推导时间复杂度呢"><a href="#如何计算或者推导时间复杂度呢" class="headerlink" title="如何计算或者推导时间复杂度呢"></a>如何计算或者推导时间复杂度呢</h1><p>我们来分析一下常规做法：</p><ol><li>确定算法中的基本操作以及问题的规模。</li><li>根据基本操作执行情况计算出规模n的函数f(n),并确定时间复杂度为T(n)=O( <strong>f(n)中增长最快的项/此项的系数</strong> ).</li></ol><p>那么是什么意思呢?记住这个利器，这三句话即可。</p><ol><li>用常数1替换所有加法常数。</li><li>在修改后的运行次数的函数中，只保留最高阶项。</li><li>如果最高阶项不是1(例如O(1)),则把该项的系数除掉，得到O</li></ol><h1 id="开始实战"><a href="#开始实战" class="headerlink" title="开始实战"></a>开始实战</h1><p>这不是演戏，这不是演习，实战之后就可以完全掌握概念了。</p><h2 id="第一类"><a href="#第一类" class="headerlink" title="第一类"></a>第一类</h2><p>看下面一对代码，进行分析：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i=<span class="number">0</span>,n=<span class="number">100</span>;        <span class="comment">/*执行了一次*/</span></span><br><span class="line">i=n/<span class="number">2</span>+n;              <span class="comment">/*执行了一次*/</span></span><br><span class="line">printf(<span class="string">"i=%d"</span>,i);     <span class="comment">/*执行了一次*/</span></span><br></pre></td></tr></table></figure></p><p>那么不难分析出这段代码一共执行了3次，那么时间复杂度就是O(3)，对吧？是不是很简单，如果真的是这样，那就错了，看我们的利器第一句，它是f(n)=3,所以应该把3改为1，即O(1)。那么看下面这个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,n=<span class="number">100</span>;        <span class="comment">/*执行了一次*/</span></span><br><span class="line">i=n/<span class="number">2</span>+n;              <span class="comment">/*执行了一次*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i=%d"</span>,i);     <span class="comment">/*执行了一次*/</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i=%d"</span>,i);     <span class="comment">/*执行了一次*/</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i=%d"</span>,i);     <span class="comment">/*执行了一次*/</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i=%d"</span>,i);     <span class="comment">/*执行了一次*/</span> </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i=%d"</span>,i);     <span class="comment">/*执行了一次*/</span></span><br></pre></td></tr></table></figure></p><p>这段代码一共执行了7次，那么时间复杂度为多少呢，经过上面的坑，这个应该没问题了，对，f(n)=7,把7改为1，即O(1)。那么我们可以得知，这种代码是具有恒定的执行时间的，也就是代码不会因为问题规模n的变化而发生变化，所以我们都记为O(1).</p><h2 id="第二类"><a href="#第二类" class="headerlink" title="第二类"></a>第二类</h2><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void <span class="function"><span class="keyword">fun</span>(<span class="title">int</span></span> n)</span><br><span class="line">&#123;</span><br><span class="line">    int i=<span class="number">1</span>,j=<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        ++j;</span><br><span class="line">        i+=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个显然n确定以后，循环的开始结束都是与i有关的，且每次自增2，假设m次后结束循环，那么i应该等于1+2m，那么就有n=1+2m，因为我们要是执行次数，也就是解得m=(n-1)/2，此时我们可以看出n/2增长的是最快的项，根据我们的法宝，我们需要把前面的系数除掉即可得到O，即(n/2)/(1/2)=n，得O(n).</p><p><em>有的为了更严谨的推导，会对上面的式子进行修改，即1+2m+K=n ，K为一个常数，因为循环的结束的时候往往i是稍稍大于n的，所以用一个K来修正这个式子，m=(n-1-K)/2,当然因为K为常数，所以不会影响最终结果，毕竟有一个增长更快的家伙把它的影响干掉了。</em></p><p>做到这，是不是感觉很简单了呢？那么我们趁热打铁进行下一个。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int <span class="built_in">i</span>=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">i</span>&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>*<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>推导时间复杂度，最重要的就是要分析算法的执行次数。那么这段程序怎么分析呢？试着自己分析一下，再来看吧。好啦，i起始值为1，每次都乘2，也就意味着每次都会距离n近一些，那么什么时候超过n而终止循环呢？很简单就是i<em>2</em>2<em>2</em>2<em>2</em>…*2&gt;n,那么假设k次之后大于n，就有2^k=n,得出k=logn(上面说了还有些log2 n，都是一样的，以后都写最简形。)<br>马上就要成功了，主要是练就分析算法和推导的思路。再来一个：<br> <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int <span class="built_in">i</span>,<span class="built_in">j</span>,x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;n;<span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">j</span>=<span class="number">0</span>;<span class="built_in">j</span>&lt;n;<span class="built_in">j</span>++)</span><br><span class="line">        x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码不用多想就知道，外循环执行n次，内循环也是执行n，则O(n^2).那么这段呢？<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int <span class="built_in">i</span>,<span class="built_in">j</span>,x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span>=<span class="number">0</span>;<span class="built_in">i</span>&lt;n;<span class="built_in">i</span>++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">j</span>=<span class="built_in">i</span>;<span class="built_in">j</span>&lt;n;<span class="built_in">j</span>++)</span><br><span class="line">        x++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于当i=0，时内循环执行了n次，i=1时，执行了n-1次，…i=n-1时，执行了1次，那么总次数为 n+(n-1)+(n-2)+..+1=n(n+1)/2,那么就是n^2/2,即O(n^2).</p><p>到这里基础的就结束了，我想大家也应该能看懂了吧，当然还有一些比较复杂的算法，大家可以去自行试试，对于该文章不懂得可以在文章下面留言，看到了我会回复的。</p><h1 id="最后给做个练习吧。"><a href="#最后给做个练习吧。" class="headerlink" title="最后给做个练习吧。"></a>最后给做个练习吧。</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">i++;</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">n</span>)  /* 方法<span class="title">function</span>(<span class="params">n</span>)为时间复杂度<span class="title">O</span>(<span class="params">n</span>)*/</span></span><br><span class="line"><span class="function"><span class="title">int</span> <span class="title">k</span>,<span class="title">m</span>;</span></span><br><span class="line"><span class="function"><span class="title">while</span>(<span class="params">k&lt;n</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">n</span>);</span></span><br><span class="line"><span class="function">    <span class="title">k</span>++;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params">k=<span class="number">0</span>;k&lt;n;k++</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(m=k;m&lt;n;m++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*时间复杂度为O(1)的序列*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小试牛刀，检验成果吧，练习完这个，函数调用的时间复杂度也被你征服了</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时间复杂度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm国内访问问题</title>
      <link href="/2018/12/23/npm%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/"/>
      <url>/2018/12/23/npm%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="使用npm安装失败-报错rollbackFailedOptional"><a href="#使用npm安装失败-报错rollbackFailedOptional" class="headerlink" title="使用npm安装失败 报错rollbackFailedOptional"></a>使用npm安装失败 报错rollbackFailedOptional</h1><p>亲自试过是可以用的，网上给了好多，在这说一下我筛选后的方法。 </p><a id="more"></a><ul><li><p>1.通过config</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> registry <span class="comment">https:</span>//<span class="comment">registry.npm.taobao.org</span> </span><br><span class="line">npm <span class="comment">info underscore</span></span><br></pre></td></tr></table></figure></li><li><p>2.通过命令行</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">npm</span> --registry https://registry.npm.taobao.org <span class="literal">info</span> underscore</span><br></pre></td></tr></table></figure></li></ul><p>设置好即可使用npm了！</p>]]></content>
      
      
      <categories>
          
          <category> Tech </category>
          
          <category> 那些年走过的坑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> macOS </tag>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
